---
title: "runMe"
author: "Tati Micheletti"
date: "1/17/2019"
output: html_document
---

## Simulation of effects of climate change on fire regime: implications for Boreal Caribou and
landbird communities in the Northwest Territories

The proposed work integrates simulation models of vegetation dynamics and wildfire with 
statistical models of songbird abundances and woodland caribou demographic parameters. The
integrated model is used to forecast the spatial distribution of selected songbird species and
the regional potential to sustain viable populations of woodland caribou, under climate change
over the 21 st century. Other applications are quantifying the overlap
between areas of high conservation value for birds and for caribou, and evaluating the
conservation potential in these respects of specific candidate protected areas. The integrated
model is implemented as a suite of modules in SpaDES, a new R-based environment for
developing and running spatial simulations over large spatial extents. The spatial extent of this
work is BCR 6 as contained within the Northwest Territories of Canada. The spatial resolution of 
the vegetation dynamics and avian habitat forecasts is 250m.

### General objectives

Item #1: Species Abundance Models (SAMs) for landbirds under current conditions.
Item #2: Land change simulation (2000-2100)
Item #3 Demographic models for caribou, SAMs for landbirds, co-occurrence under future
conditions

### Integrated modules overview

The metamodule is composed of 8 parent modules (i.e. groups of modules), as follows:
![Module structure that composes the NWT project.](https://github.com/tati-micheletti/NWT/raw/master/inputs/ModelStructure_2.jpg)

The structure of each one of the modules is as follows:

\textcolor{blue}{LandR}: This group of modules is composed of one module and one group of modules.
                         The first module, `Boreal_LBMRDataPrep` creates the specific parameters 
                         to be used on the specified study area (BRC6 within NWT). The group of 
                         modules (`LandR_Biomass`) is composed of (1) `LandR_BiomassGMOrig`: is 
                         responsible for growth and mortality, (2) `Biomass_regeneration`: does 
                         post-disturbance biomass regeneration for LandR, and (3) `LBMR`: this is 
                         the module in LandR that is responsible for the forest succession. LandR 
                         needs at least these last three modules to work.

\textcolor{blue}{birdsNWT}: The birds module loads an existing glm object for each sp located in  
                            https://drive.google.com/open?id=1obSvU4ml8xa8WMQhQprd6heRrN47buvI. 
                            The model uses dynamic (vegetation: biomass of tree species) and static
                            layers (Non-veg: WAT = water (1/0), URBAG = urban/agriculture (1/0),
                            lLED25 = lake edge density with 5x5 moving window (continuous), 
                            DEV25 = development proportion within 5x5 moving window (continuous),
                            and landform (categorical). North American landcover 2005 (MODIS) is
                            source for all but landform (from AdaptWest land facet datset). 
                            Vector ruggedness (already available - 
                            https://drive.google.com/open?id=1dgIw70mDpDYrBExA52SkPoS1TFaZdLE9) 
                            and road density (that should be available from the Anthropogenic
                            module) will be added to the nect version of these models. The birds' 
                            prediction is masked to uplands as we do not have data for lowlands. 

\textcolor{blue}{caribou}: The `caribou` module is composed of two main modules: `caribouRSF` and `caribouPopGrowth`. 
                           The `caribouPopGrowth` needs, however, a second module called `caribouRecDistRelationship`, 
                           which creates the necessary model object based on the coefficients of Table 56 from ECCC 2012
                           report. For the `caribouPopGrowth` uses a simple population growth module that is
                           not density dependent, and is deterministic. Improvements will be implemented in time. 
                           It is also important to highlight that the female survival is set at 0.85 due to
                           lack of data for the specific location, and initial population size was set to `353` 
                           (based on normal). 
                           Another factor is that up to now, only model `M3` is being run, but there is a basic 
                           support to implement the other models.

\textcolor{blue}{FireSense}: To be completed by JM.

\textcolor{blue}{anthropogenic}: To be completed by MT.

### Update and/or install all needed packages

If you don't have all packages installed yet, please 
first update all your packages and then install SpaDES. 
Make sure you restart your session after installing all packages.

```{r github, include=FALSE, eval = FALSE}
knitr::opts_chunk$set(echo = TRUE)

update.packages(checkBuilt = TRUE)
devtools::install_github("PredictiveEcology/reproducible@development")
devtools::install_github("achubaty/amc@development")
devtools::install_github("PredictiveEcology/pemisc@development")
devtools::install_github("PredictiveEcology/map@development")
devtools::install_github("PredictiveEcology/LandR@development") # Updates SpaDES.tools and SpaDES.core quickPlot

```

### Setting up directories and paths for the simulation

First, make sure you have the correct R version. These model was created using 
the following R version and might not workcorrectly in other versions:

```{r rVersion}

message(paste0("This model uses R version 3.5.2 (2018-12-20). Your session runs ", 
               sessionInfo()[["R.version"]][["version.string"]]))

```

Second, load all needed dependencies. 

```{r libraries}

library("LandR")
library("SpaDES")
library("raster")
library("plyr"); library("dplyr")
library("magrittr") # for piping

# Source all common functions
invisible(sapply(X = list.files(file.path(getwd(), "functions"), full.names = TRUE), FUN = source))

```

After having all installed correctly, we need to make sure all the submodules are sync to your machine:

```{r initSubmodules, eval = FALSE}

# system("git submodule init", wait = TRUE) # Use only the first time you are running the project
# system("git submodule sync | git submodule update --init --recursive --remote", wait = TRUE) # Use only the first time you are running the project
# system(paste0("cd ", getwd(),
#               " && git submodule foreach git fetch"), wait = TRUE) # Only need to run when you need to fetch other branches
system(paste0("cd ", getwd(),
              " && git submodule foreach git pull"), wait = TRUE)
system(paste0("cd ", getwd(),
              " && git pull"), wait = TRUE)
message("These are the specific commits and branches of each submodule:")
system("git submodule", wait = TRUE) # checks if the branches and commits you are using are the correct ones
```

Now we can start setting up the simulations.
First we will set paths to the directories, the cloud cache folder and some 
options used by SpaDES.

```{r setup}

user <- pemisc::user()
# Which computer is this being run on?
# Options are: BorealCloud, LocalMachine, 388
whichComputer <- if (user == "emcintir") "LocalMachine" else if (user == "tmichele") "BorealCloud" else "LocalMachine"

paths <- pathsSetup(whichComputer = whichComputer) 
if (length(paths$modulePath) == 1) paths$modulePath <- c(paths$modulePath, file.path(paths$modulePath, "scfm/modules"))

if (pemisc::user() %in% c("Tati", "tmichele")) {
    setTempFolder(paths = paths, setTmpFolder = TRUE, usr = user)
}

# <<!!!>> ATTENTION <<!!!>>

# If setTmpFolder == TRUE, a temporary folder will be created inside the cache folder set. 
# This can/should be changed later for other projects using:

# ===> In Windows:
# file.edit(file.path(Sys.getenv('R_USER'), '.Renviron'))
# Change the path in TMPDIR to the desired path to temp folder and save the file. 
# Restart your R session for the changes to take effect.

# ===> In Linux/MacOS:
# tryCatch(library(unixtools),
#   error = function(e) install.packages("unixtools", repos = 'http://www.rforge.net/'))
#   unixtools::set.tempdir(<path/to/tempFolder>)
# Restart your R session for the changes to take effect.

# We also need to set a 'scratch' temporary folder for raster (if our home folder doesn't have enough space)
maxMemory <- 5e+12
scratchDir <- checkPath(path = paste0("/mnt/tmp/rasterTMP/", user), create = TRUE)
#Here we check that the creation of the folder worked (we might have problems with writting access, only tested with my own user)
if(dir.create(scratchDir)) system(paste0("sudo chmod -R 777 /mnt/tmp/rasterTMP"), wait = TRUE) 
rasterOptions(default = TRUE)
options(rasterMaxMemory = maxMemory, rasterTmpDir = scratchDir)

# Sessting up the cache folder: it is hosted in the project's GDrive
cloudFolderID <- "https://drive.google.com/open?id=1PoEkOkg_ixnAdDqqTQcun77nUvkEHDc0"
tilePath <- file.path(paths$outputPath, "tiles")

# Setting all SpaDES options to be used in the project
.plotInitialTime <- NA
opts <- options(
  "future.globals.maxSize" = 1000*1024^2,
  "LandR.assertions" = FALSE,
  "LandR.verbose" = 1,
  "map.dataPath" = paths$inputPath,
  "map.overwrite" = TRUE,
  "map.tilePath" = tilePath,
  "map.useParallel" = TRUE, #!identical("windows", .Platform$OS.type),
  "reproducible.futurePlan" = FALSE,
  "reproducible.inputPaths" = if (pemisc::user("emcintir")) "~/data" else NULL,
  "reproducible.quick" = FALSE,
  "reproducible.overwrite" = TRUE,
  "reproducible.useMemoise" = TRUE, # Brings cached stuff to memory during the second run
  "reproducible.useNewDigestAlgorithm" = TRUE,  # use the new less strict hashing algo
  "reproducible.useCache" = TRUE,
  "reproducible.cachePath" = paths$cachePath,
  "reproducible.showSimilar" = TRUE,
  "reproducible.useCloud" = if (pemisc::user("emcintir")|pemisc::user("tmichele")) FALSE else TRUE,
  "spades.moduleCodeChecks" = FALSE, # Turn off all module's code checking
  "spades.useRequire" = FALSE # assuming all pkgs installed correctly
)

SpaDES.core::setPaths(modulePath = paths$modulePath, inputPath = paths$inputPath, 
                      outputPath = paths$outputPath, cachePath = paths$cachePath)

```

### Creating study area

The study area is comprised of the *BCR6* (Bird Conservation Regions no. 6) within the *Northwest Territories*.  
We have developed a specific function to select this area, which is cached both locally and remotely 
in a google drive's folder (`cloudFolderID`), which is sharable with all project's team members.

```{r studyArea}
if (quickPlot::isRstudioServer()) options(httr_oob_default = TRUE)

Edehzhie.url <- "https://drive.google.com/open?id=1klq0nhtFJZv47iZVG8_NwcVebbimP8yT"
EdehzhieOfficial.url <- "https://drive.google.com/open?id=1fYvNPwovjNtTABoGcegrvdFGkNfCUsxf"
NWT.url <- "https://drive.google.com/open?id=1LUxoY2-pgkCmmNH5goagBp3IMpj6YrdU"
        
studyAreaEde <- cloudCache(prepInputs,
                           url = Edehzhie.url,
                           destinationPath = paths$inputPath[[1]],
                           cloudFolderID = cloudFolderID,
                           omitArgs = c("destinationPath", "cloudFolderID"))
        
studyArea <- cloudCache(prepInputs,
                        url = NWT.url, studyArea = studyAreaEde,
                        destinationPath = paths$inputPath[[1]],
                        cloudFolderID = cloudFolderID,
                        omitArgs = c("destinationPath", "cloudFolderID"))

studyAreaNWT <- cloudCache(prepInputs,
                        url = NWT.url,
                        destinationPath = paths$inputPath[[1]],
                        cloudFolderID = cloudFolderID,
                        omitArgs = c("destinationPath", "cloudFolderID"))
```

### Running `LandR_Biomass`

To run the first set of modules, both the parametrization model (`Boreal_LBMRDataPrep`) and the forest succession group of modules (`LandR_Biomass`), 
we explicitly specify the modules to be run, and the running time for the simulations:

```{r run_LandR}

# modulesLandR_SCFM <- list("scfmLandcoverInit", "scfmRegime", "scfmDriver", "scfmIgnition", "scfmEscape", "scfmSpread",
#                           "Boreal_LBMRDataPrep", "LandR_BiomassGMOrig","Biomass_regeneration", "LBMR")
# modulesSCFM <- list("scfmLandcoverInit", "scfmRegime", "scfmDriver", "scfmIgnition", "scfmEscape", "scfmSpread")
# modulesLandR <- list("Boreal_LBMRDataPrep", "LandR_BiomassGMOrig","Biomass_regeneration", "LBMR")
# modulesBirds <- list("birdsNWT")
# modulesBirds_Fire <- list("scfmLandcoverInit", "scfmRegime", "scfmDriver", "scfmIgnition", "scfmEscape", "scfmSpread",
#                           "Boreal_LBMRDataPrep", "LandR_BiomassGMOrig","Biomass_regeneration", "LBMR",
#                           "birdsNWT")
modulesBirdsFireCaribou <- list("scfmLandcoverInit", "scfmRegime", "scfmDriver", "scfmIgnition", "scfmEscape", "scfmSpread",
                                "Boreal_LBMRDataPrep", "LandR_BiomassGMOrig","Biomass_regeneration", "LBMR",
                                "birdsNWT",
                                "caribouRecDistRelationship", "caribouPopGrowthModel") # Still need to implement the disturbance
# modulesWetland <- list("waterlandClassification")

times <- list(start = 0, end = 100)

```

Then we need to set the parameters for the simulation call:

``` {r params}

# This raster to match contains only the uplands, it is 
rasterToMatch <- cloudCache(prepInputs, url = "https://drive.google.com/open?id=1fo08FMACr_aTV03lteQ7KsaoN9xGx1Df", 
                            studyArea = studyAreaNWT,
                            targetFile = "RTM.tif", destinationPath = paths$inputPath, 
                            useCloud = getOption("reproducible.useCloud", FALSE),
                            cloudFolderID = cloudFolderID, overwrite = TRUE, filename2 = NULL,
                            omitArgs = c("destinationPath", "cloudFolderID", "useCloud", "overwrite", "filename2"))

sppEquivCol <- "NWT"

#SCFM
defaultInterval <- 1.0
defaultPlotInterval <- 1.0
defaultInitialSaveTime <- NA #don't be saving nuffink

parameters <- list(
  # Caribou
  caribouPopGrowthModel = list(
    ".plotInitialTime" = NULL,
    "recoveryTime" = 40
  ),
  # BirdsNWT
  birdsNWT = list(
    "baseLayer" = 2005,
    "overwritePredictions" = TRUE,
    "useTestSpeciesLayers" = FALSE,
    "useParallel" = TRUE
  ),
  #SCFM
    ".progress" = list(type = "text", interval = 1),
    scfmLandcoverInit = list(
    ".plotInitialTime" = NULL
  ),
  scfmIgnition = list(
    "pIgnition" = 0.0001,
    "returnInterval" = defaultInterval,
    "startTime" = times$start,
    ".plotInitialTime" = NA,
    ".plotInterval" = defaultPlotInterval,
    ".saveInitialTime" = defaultInitialSaveTime,
    ".saveInterval" = defaultInterval),
  scfmEscape = list(
    "p0" = 0.05,
    "returnInterval" = defaultInterval,
    "startTime" = times$start,
    ".plotInitialTime" = NA,
    ".plotInterval" = defaultPlotInterval,
    ".saveInitialTime" = defaultInitialSaveTime,
    ".saveInterval" = defaultInterval),
  scfmSpread = list(
    "pSpread" = 0.235,
    "returnInterval" = defaultInterval,
    "startTime" = times$start,
    ".plotInitialTime" = times$start,
    ".plotInterval" = defaultPlotInterval,
    ".saveInitialTime" = defaultInitialSaveTime,
    ".saveInterval" = defaultInterval),
  scfmRegime = list(fireCause=c("L", "H")),
  scfmDriver = list(targetN = 1500),
  # LandR_Biomass
  LBMR = list(
    ".useParallel" = 3,
    ".plotInitialTime" = NA,
    "seedingAlgorithm" = "wardDispersal",
    ".useCache" = FALSE,
    "successionTimestep" = 10,
    "initialBiomassSource" = "cohortData"),
  LandR_BiomassGMOrig = list( # dev branch
    "growthInitialTime" = 0,
    "successionTimestep" = 10),
  Boreal_LBMRDataPrep = list(
    "cacheIDmodelBiomass" = "b2209ccb1cb19ee1",
    "useCloudCacheForStats" = if (pemisc::user("tmichele")) FALSE,
    "sppEquivCol" = sppEquivCol,
    "successionTimestep" = 10,
    "pixelGroupAgeClass" = 10,
    ".useCache" = c(".inputObjects", "init")
  )
)

```

Now we have to set the objects. The first object is a list of trees of interest:

```{r treeSp, echo = FALSE}

# Tree species specified for the project (see "Meeting minute January 16th, 2019" from Google Drive)
# spTable <- data.frame(CommonName = c("Jack pine", "Black spruce", "White spruce", 
#                                      "Balsam poplar", "Trembling aspen", "Paper birch"),
#                       ScientificName = c("Pinus banksian", "Picea mariana", "Picea glauca", 
#                                          "Populus balsamifera", "Populus tremuloides", 
#                                          "Betula papyrifera"),
#                       LandR = c("Pinu_ban", "Pice_mar", "Pice_gla", "Popu_bal", 
#                                 "Popu_tre", "Betu_pap"))
# knitr::kable(spTable)
# Bird model's tree species [30JAN19]:
NWTsp <- c("Abie_Bal", "Betu_Pap", "Lari_Lar", "Pice_Gla",
                "Pice_Mar", "Pinu_Ban", "Pinu_Con", "Popu_Bal", "Popu_Tre")

# Equivalency table for tree species
data("sppEquivalencies_CA", package = "LandR")

# Make NWT spp equivalencies
# Popu_Tri == Popu_Bal in NWT
# Quer_mac in LandR needs to be Quer_Mac in NWT
sppEquivalencies_CA[, NWT := c(Abie_Bal = "Abie_Bal", 
                               Betu_Pap = "Betu_Pap", 
                               Lari_Lar = "Lari_Lar", 
                               Pice_Gla = "Pice_Gla",
                               Pice_Mar = "Pice_Mar", 
                               Pinu_Ban = "Pinu_Ban", 
                               Pinu_Con = "Pinu_Con", 
                               Popu_Bal = "Popu_Bal", 
                               Popu_Tre = "Popu_Tre",
                               Popu_Tri = "Popu_Bal")[Boreal]]

# knitr::kable(sppEquivalencies_CA[NWT %in% NWTsp])
# create color palette for species used in model

sppColors <- LandR::sppColors(sppEquiv = sppEquivalencies_CA, sppEquivCol = sppEquivCol,
                              palette = "Set3")
mixed <- structure("#D0FB84", names = "Mixed")
sppColors[length(sppColors)+1] <- mixed
attributes(sppColors)$names[length(sppColors)] <- "Mixed"

```

And finally, we load the objects used by this group of modules:

``` {r objects}

.objects <- list(
  "birdsList" = c("BBWA", "BOCH"), ### JUST TO TEST. REMOVE ONCE WORKING
  "rasterToMatch" = rasterToMatch,
  "studyAreaLarge" = studyAreaNWT,
  "sppEquiv" = sppEquivalencies_CA,
  "sppEquivCol" = sppEquivCol,
  "sppColors" = sppColors,
  "omitNonVegPixels" = TRUE,
  "cloudFolderID" = cloudFolderID,
  "studyArea" = studyAreaNWT
  )

```

After supplying the objects, we run the simulation initialization function, passing all arguments of interest:

``` {r simInit}

outputsLandR <- data.frame(
  objectName = c("burnMap",
                 "cohortData",
                 "simulationTreeOutput",
                 "summaryBySpecies",
                 "summaryBySpecies1",
                 "simulationOutput"),
  file = c(paste0("rstCurrentBurn_", toupper(format(Sys.time(), "%d%b%y"))),
           paste0("cohortData_", toupper(format(Sys.time(), "%d%b%y"))),
           paste0("simulationTreeOutput_", toupper(format(Sys.time(), "%d%b%y"))),
           paste0("summaryBySpecies_", toupper(format(Sys.time(), "%d%b%y"))),
           paste0("summaryBySpecies1_",toupper(format(Sys.time(), "%d%b%y"))),
           paste0("simulationOutput_",toupper(format(Sys.time(), "%d%b%y")))))

```

And finally the simulation call (note that the argument `debug = TRUE` lists all processes that are happening):

```{r call}

# Other combinations of module that can be used
# SCFM <- simInitAndSpades(times = times,
#                          params = parameters,
#                          modules = modulesSCFM,
#                          objects = .objects, paths = paths,
#                          loadOrder = unlist(modulesSCFM), debug = 2)
# LandR_SCFM <- simInitAndSpades(times = times, params = parameters,
#                     modules = modulesLandR_SCFM, outputs = outputsLandR,
#                     objects = .objects, paths = paths,
#                     loadOrder = unlist(modulesLandR_SCFM), debug = 2)
# LandR_Biomass <- simInitAndSpades(times = times, params = parameters,
#                     modules = modulesLandR,
#                     objects = .objects, paths = paths,
#                     loadOrder = unlist(modulesLandR),
#                     outputs = outputsLandR, debug = 2)
# birds <- simInitAndSpades(times = times, params = parameters,
#                     modules = modulesBirds,
#                     objects = .objects, paths = paths,
#                     loadOrder = unlist(modulesBirds), debug = 2)
# birdsAndFire <- simInitAndSpades(times = times, params = parameters,
#                     modules = modulesBirds_Fire,
#                     objects = .objects, paths = paths,
#                     loadOrder = unlist(modulesBirds_Fire),
#                     outputs = outputsLandR, debug = 2)

# Most complete model to run
# birdsFireCaribou <- simInitAndSpades(times = times, params = parameters,
#                     modules = modulesBirdsFireCaribou,
#                     objects = .objects, paths = paths,
#                     loadOrder = unlist(modulesBirdsFireCaribou),
#                     outputs = outputsLandR, debug = 2)

birdsFireCaribouV1 <- simInitAndSpades(times = times, params = parameters,
                    modules = modulesBirdsFireCaribou,
                    objects = .objects, paths = paths,
                    loadOrder = unlist(modulesBirdsFireCaribou),
                    outputs = outputsLandR, debug = 2)
```
