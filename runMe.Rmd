---
title: "runMe"
author: "Tati Micheletti"
date: "1/17/2019"
output: html_document
---

## Simulation of effects of climate change on fire regime: implications for Boreal Caribou and
landbird communities in the Northwest Territories

The proposed work integrates simulation models of vegetation dynamics and wildfire with 
statistical models of songbird abundances and woodland caribou demographic parameters. The
integrated model is used to forecast the spatial distribution of selected songbird species and
the regional potential to sustain viable populations of woodland caribou, under climate change
over the 21 st century. Other applications are quantifying the overlap
between areas of high conservation value for birds and for caribou, and evaluating the
conservation potential in these respects of specific candidate protected areas. The integrated
model is implemented as a suite of modules in SpaDES, a new R-based environment for
developing and running spatial simulations over large spatial extents. The spatial extent of this
work is BCR 6 as contained within the Northwest Territories of Canada. The spatial resolution of 
the vegetation dynamics and avian habitat forecasts is 250m.

### General objectives

Item #1: Species Abundance Models (SAMs) for landbirds under current conditions.
Item #2: Land change simulation (2000-2100)
Item #3 Demographic models for caribou, SAMs for landbirds, co-occurrence under future
conditions

### Integrated modules overview

The metamodule is composed of 8 parent modules (i.e. groups of modules), as follows:
![Module structure that composes the NWT project.](https://github.com/tati-micheletti/NWT/raw/master/inputs/ModelStructure_2.jpg)

The structure of each one of the modules is as follows:

\textcolor{blue}{LandR}: This group of modules is composed of one module and one group of modules. The first module, `Boreal_LBMRDataPrep` creates the specific parameters to be used on the specified study area (BRC6 within NWT). The group of modules (`LandR_Biomass`) is composed of (1) `LandR_BiomassGMOrig`: is responsible for growth and mortality, (2) `Biomass_regeneration`: does post-disturbance biomass regeneration for LandR, and (3) `LBMR`: this is the module in LandR that is responsible for the forest succession. LandR needs at least these last three modules to work.

\textcolor{blue}{birdsNWT}: To be completed later by TM.

\textcolor{blue}{caribou}: The `caribou` module is composed of two modules: `caribouRSF` and `caribouPopGrowth` (names to be fixed by FS) 

\textcolor{blue}{FireSense}: To be completed by JM.

\textcolor{blue}{anthropogenic}: To be completed by MT.

### Update and/or install all needed packages

If you don't have all packages installed yet, please 
first update all your packages and then install SpaDES. 
Make sure you restart your session after installing all packages.

```{r setup, include=FALSE, eval = FALSE}
knitr::opts_chunk$set(echo = TRUE)

update.packages(checkBuilt = TRUE)
devtools::install_github("PredictiveEcology/reproducible@development")
devtools::install_github("achubaty/amc@development")
devtools::install_github("PredictiveEcology/pemisc@development")
devtools::install_github("PredictiveEcology/map@development")
devtools::install_github("PredictiveEcology/LandR@development")
devtools::install_github("PredictiveEcology/quickPlot@development")
devtools::install_github("PredictiveEcology/SpaDES.tools@development")
devtools::install_github("PredictiveEcology/SpaDES.core@development")

```

### Setting up directories and paths for the simulation

First, make sure you have the correct R version. These model was created using 
the following R version and might not workcorrectly in other versions:

```{r rVersion}

message(paste0("This model uses R version 3.5.2 (2018-12-20). Your session runs ", 
               sessionInfo()[["R.version"]][["version.string"]]))

```

Second, load all needed dependencies. 

```{r libraries}

library("LandR")
library("SpaDES")
library("raster")
library("magrittr") # for piping
system(paste0("find . -size +50M | cat >> .gitignore | 
                        sort .gitignore | uniq "), ignore.stdout = TRUE, wait = TRUE)
# Source all common functions
invisible(sapply(X = list.files(file.path(getwd(), "functions"), full.names = TRUE), FUN = source))

```

After having all installed correctly, we need to make sure all the submodules are sync to your machine:

```{r initSubmodules, eval = FALSE}

# system("git submodule init", wait = TRUE) # Use only the first time you are running the project
# system("git submodule sync | git submodule update --init --recursive --remote", wait = TRUE) # Use only the first time you are running the project
system(paste0("cd ", getwd(),
              " && git submodule foreach git fetch"), wait = TRUE)
system(paste0("cd ", getwd(),
              " && git submodule foreach git pull"), wait = TRUE)
system(paste0("cd ", getwd(),
              " && git pull"), wait = TRUE)
message("These are the specific commits and branches of each submodule:")
system("git submodule", wait = TRUE) # checks if the branches and commits you are using are the correct ones
```

Now we can start setting up the simulations.
First we will set paths to the directories, the cloud cache folder and some 
options used by SpaDES.

```{r setup}
# Which computer is this being run on?
# Options are: BorealCloud, LocalMachine, 388
whichComputer <- "388"

paths <- pathsSetup(whichComputer = whichComputer, setTmpFolder = TRUE) 
# If setTmpFolder == TRUE, a temporary folder will be created inside the cache folder set. 
# This can/should be changed later for other projects using:
# ===> In Windows:
# write(TMPDIR = '<path/to/tempFolder>'), file = file.path(Sys.getenv('R_USER'), '.Renviron'))
# ===> In Linux/MacOS:
# tryCatch(library(unixtools),
#   error = function(e) install.packages("unixtools", repos = 'http://www.rforge.net/'))
#   unixtools::set.tempdir(<path/to/tempFolder>)

# Sessting up the cache folder: it is hosted in the project's GDrive
cloudFolderID <- "https://drive.google.com/open?id=1PoEkOkg_ixnAdDqqTQcun77nUvkEHDc0"
tilePath <- file.path(paths$outputPath, "tiles")

# Setting all SpaDES options to be used in the project
.plotInitialTime <- 0
opts <- options(
  "future.globals.maxSize" = 1000*1024^2,
  "LandR.assertions" = FALSE,
  "LandR.verbose" = 1,
  "map.dataPath" = paths$inputPath,
  "map.overwrite" = TRUE,
  "map.tilePath" = tilePath,
  "map.useParallel" = TRUE, #!identical("windows", .Platform$OS.type),
  "reproducible.futurePlan" = FALSE,
  "reproducible.inputPaths" = NULL,
  "reproducible.quick" = FALSE,
  "reproducible.overwrite" = TRUE,
  "reproducible.useMemoise" = TRUE, # Brings cached stuff to memory during the second run
  "reproducible.useNewDigestAlgorithm" = TRUE,  # use the new less strict hashing algo
  "reproducible.useCache" = TRUE,
  "reproducible.cachePath" = paths$cachePath,
  "reproducible.useCloud" = TRUE,
  "spades.moduleCodeChecks" = FALSE, # Turn off all module's code checking
  "spades.useRequire" = FALSE # assuming all pkgs installed correctly
)

SpaDES.core::setPaths(modulePath = paths$modulePath, inputPath = paths$inputPath, 
                      outputPath = paths$outputPath, cachePath = paths$cachePath)

```

### Creating study area

The study area is comprised of the *BCR6* (Bird Conservation Regions no. 6) within the *Northwest Territories*.  
We have developed a specific function to select this area, which is cached both locally and remotely 
in a google drive's folder (`cloudFolderID`), which is sharable with all project's team members.

```{r studyArea}

studyArea <- cloudCache(defineStudyArea, testArea = TRUE, mapSubset = "Northwest Territories",
                        destinationPath = paths$inputPath, specificTestArea = "BCR6",
                        useCloud = TRUE, cloudFolderID = cloudFolderID) %>%  rgeos::gUnaryUnion()

```

### Running `LandR_Biomass`

To run the first set of modules, both the parametrization model (`Boreal_LBMRDataPrep`) and the forest succession group of modules (`LandR_Biomass`), 
we explicitly specify the modules to be run, and the running time for the simulations:

```{r run_LandR}

modules <- list("waterlandClassification")
times <- list(start = 1, end = 1)

```

Then we need to set the parameters for the simulation call:

``` {r params}

rasterToMatch <- cloudCache(prepInputs, url = "https://drive.google.com/open?id=1fo08FMACr_aTV03lteQ7KsaoN9xGx1Df", studyArea = studyArea,
                            targetFile = "RTM.tif", destinationPath = paths$inputPath, 
                            useCloud = TRUE, cloudFolderID = cloudFolderID)

# rasterToMatch[7080245] <- NA # Quick fix for the NA in the newLCCClasses table (hopefully) 
sppEquivCol <- "LandWeb"
parameters <- list(
  LBMR = list(".plotInitialTime" = 0,
              "seedingAlgorithm" = "wardDispersal",
              "useCache" = TRUE,
              "successionTimestep" = 10), 
  waterlandClassification = list("baseLayer" = c("LCC05", "LCC10"),
              wetValue = NA),
  LandR_BiomassGMOrig = list( # dev branch
    "growthInitialTime" = 0,
    "successionTimestep" = 10),
  Boreal_LBMRDataPrep = list(
    "sppEquivCol" = sppEquivCol,
    "successionTimestep" = 10,
    "pixelGroupAgeClass" = 10
  )
)

```

Now we have to set the objects. The first object is a list of trees of interest:

```{r treeSp, echo = FALSE}

# Tree species specified for the project (see "Meeting minute January 16th, 2019" from Google Drive)
# spTable <- data.frame(CommonName = c("Jack pine", "Black spruce", "White spruce", 
#                                      "Balsam poplar", "Trembling aspen", "Paper birch"),
#                       ScientificName = c("Pinus banksian", "Picea mariana", "Picea glauca", 
#                                          "Populus balsamifera", "Populus tremuloides", 
#                                          "Betula papyrifera"),
#                       LandR = c("Pinu_ban", "Pice_mar", "Pice_gla", "Popu_bal", 
#                                 "Popu_tre", "Betu_pap"))
# knitr::kable(spTable)

# Equivalency table for tree species
data("sppEquivalencies_CA", package = "LandR")
sppEquivalencies_CA[grep("Pin", LandR), `:=`(EN_generic_short = "Pine",
                                             EN_generic_full = "Pine",
                                             Leading = "Pine leading")]

# Make LandWeb spp equivalencies
sppEquivalencies_CA[, LandWeb := c(Pice_mar = "Pice_mar", Pice_gla = "Pice_gla",
                                   Pinu_con = "Pinu_sp", Pinu_ban = "Pinu_sp",
                                   Popu_tre = "Popu_sp", Betu_pap = "Popu_sp",
                                   Abie_bal = "Abie_sp", Abie_las = "Abie_sp", Abie_sp = "Abie_sp")[LandR]]

sppEquivalencies_CA[LandWeb == "Abie_sp", EN_generic_full := "Fir"]
sppEquivalencies_CA[LandWeb == "Abie_sp", EN_generic_short := "Fir"]
sppEquivalencies_CA[LandWeb == "Abie_sp", Leading := "Fir leading"]

sppEquivalencies_CA[LandWeb == "Popu_sp", EN_generic_full := "Deciduous"]
sppEquivalencies_CA[LandWeb == "Popu_sp", EN_generic_short := "Decid"]
sppEquivalencies_CA[LandWeb == "Popu_sp", Leading := "Deciduous leading"]

# create color palette for species used in model

sppColors <- LandR::sppColors(sppEquivalencies_CA, sppEquivCol, newVals = "Mixed", palette = "Accent")

```


And finally, we load the objects used by this group of modules:

``` {r objects}

.objects <- list(
  # "rasterToMatch" = rasterToMatch,
  "studyArea" = studyArea,
  "studyAreaLarge" = studyArea,
  "sppEquiv" = sppEquivalencies_CA,
  "sppEquivCol" = sppEquivCol,
  "sppColors" = sppColors,
  "omitNonVegPixels" = TRUE
  )

```

After supplying the objects, we run the simulation initialization function, passing all arguments of interest:

``` {r simInit}

mySim <- simInit(times = times, params = parameters, modules = modules, objects = .objects,
                 paths = paths, loadOrder = unlist(modules))

```

And finally the simulation call (note that the argument `debug = TRUE` lists all processes that are happening):

```{r call}

Wetlands <- spades(mySim, debug = TRUE)

```
